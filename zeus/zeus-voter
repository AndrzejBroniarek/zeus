#!/usr/bin/env python
# -*- coding: utf-8 -*-

import re

from zeus.core import ( c2048, get_random_selection,
                        gamma_encode, to_relative_answers,
                        encrypt, prove_encryption)

from httplib import HTTPConnection, HTTPSConnection
from urlparse import urlparse
from urllib import urlencode
from os.path import exists
from sys import argv, stderr
from json import loads, dumps
from Queue import Queue, Empty
from threading import Thread

p, g, q, x, y = c2048()

def generate_voter_file(nr, domain='zeus.minedu.gov.gr'):
    return '\n'.join((u'voter-%d@%s, Ψηφοφόρος, %d' % (i, domain, i))
                     for i in xrange(nr))

def generate_vote(p, g, q, y, choices):
    if isinstance(choices, int):
        nr_candidates = choices
        selection = get_random_selection(nr_candidates, full=0)
    else:
        nr_candidates = max(choices) + 1
        selection = to_relative_answers(choices, nr_candidates)
    encoded = gamma_encode(selection, nr_candidates)
    ct = encrypt(encoded, p, g, q, y)
    alpha, beta, rand = ct
    proof = prove_encryption(p, g, q, alpha, rand)
    commitment, challenge, response = proof
    answer = {}
    answer['encryption_proof'] = (commitment, challenge, response)
    answer['choices'] = [{'alpha': alpha, 'beta': beta}]
    encrypted_vote = {}
    encrypted_vote['answers'] = [answer]
    encrypted_vote['election_uuid'] = ''
    encrypted_vote['election_hash'] = ''
    return encrypted_vote, encoded

def get_http_connection(url):
    parsed = urlparse(url)
    if parsed.scheme == 'https':
            default_port = '443'
            Conn = HTTPSConnection
    else:
            default_port = '80'
            Conn = HTTPConnection
    host, sep, port = parsed.netloc.partition(':')
    if not port:
        port = default_port
    netloc = host + ':' + port
    conn = Conn(netloc)
    conn.path = parsed.path
    return conn

def get_election(voter_url):
    conn = get_http_connection(voter_url)
    voter_path = conn.path
    conn.request('GET', voter_path)
    response = conn.getresponse()
    response.read()
    cookie = response.getheader('Set-Cookie')
    if not cookie:
        raise RuntimeError("Cannot get cookie")
    cookie = cookie.split(';')[0]
    cast_path = '/'.join(voter_path.split('/')[:-3]) + '/cast'
    headers = {'Cookie': cookie}

    # where csrf token lives
    election_view = response.getheader('location')
    conn.request('GET', "/" + election_view.split("/", 3)[3], headers=headers)
    response = conn.getresponse()
    try:
        token = re.findall(".*token\%3D(.*)\%26", response.read())[0]
    except Exception:
        m = "Cannot vote"
        raise RuntimeError(m)

    election_path = '/'.join(voter_path.split('/')[:-3])
    conn.request('GET', election_path, headers=headers)
    response = conn.getresponse()
    election = loads(response.read())
    pk = election['public_key']
    p = int(pk['p'])
    g = int(pk['g'])
    q = int(pk['q'])
    y = int(pk['y'])
    answers = election['questions'][0]['answers']
    return conn, cast_path, token, headers, answers, p, g, q, y

def do_cast_vote(conn, cast_path, token, headers, vote):
    body = urlencode({'encrypted_vote': dumps(vote), 'csrf_token': token})
    conn.request('POST', cast_path, headers=headers, body=body)
    response = conn.getresponse()
    body = response.read()
    if response.status != 200:
        print response.status
    conn.close()

def cast_vote(voter_url, choices=None):
    election_info = get_election(voter_url)
    conn, cast_path, token, headers, answers, p, g, q, y = election_info
    choices = choices if choices is not None else len(answers)
    vote, encoded = generate_vote(p, g, q, y, choices)
    do_cast_vote(conn, cast_path, token, headers, vote)
    return encoded

def main_generate(nr, domain, voters_file):
    if exists(voters_file):
        m = "%s: file exists, will not overwrite" % (voters_file,)
        raise ValueError(m)

    with open(voters_file, "w") as f:
        f.write(generate_voter_file(nr, domain=domain).encode('utf-8'))

def main_random_cast_thread(inqueue, outqueue):
    while 1:
        try:
            o = inqueue.get_nowait()
            if not o:
                break
        except Empty, e:
            break
        i, total, voter_url = o
        print "%d/%d" % (i, total)
        encoded = cast_vote(voter_url)
        outqueue.put(encoded)

def main_random_cast(voter_url_file, plaintexts_file, nr_threads=2):
    if exists(plaintexts_file):
        m = "%s: file exists, will not overwrite" % (plaintexts_file,)
        raise ValueError(m)
    f = open(plaintexts_file, "w")

    voter_urls = open(voter_url_file).read().splitlines()
    total = len(voter_urls)
    inqueue = Queue(maxsize=total)
    outqueue = Queue(maxsize=total)
    for i, voter_url in enumerate(voter_urls):
        inqueue.put((i, total, voter_url))

    #main_random_cast_thread(queue)
    threads = [Thread(target=main_random_cast_thread, args=(inqueue, outqueue))
               for _ in xrange(nr_threads)]

    for t in threads:
        t.daemon = True
        t.start()

    plaintexts = [outqueue.get() for _ in xrange(total)]
    f.write(repr(plaintexts))
    f.close()

    for t in threads:
        t.join()

def main_show(url):
    conn, cast_path, token, answers, p, g, q, y = get_election(url)
    for i, c in enumerate(answers):
        if isinstance(c, unicode):
            c = c.encode('utf-8')
        print "%d: %s" % (i, c)

def main_vote(url, choice_str):
    choices = [int(x) for x in choice_str.split(',')]
    print cast_vote(url, choices)

def main_help():
    usage = ("Usage: ./zeus-voter generate <nr> <domain> <voters.csv>\n"
             "       ./zeus-voter random_cast <voter_url_file> <plaintexts_file> [nr_threads]\n"
             "       ./zeus-voter show <voter_url>\n"
             "       ./zeus-voter vote <voter_url> <1st>,<2nd>,... (e.g.)\n")
    stderr.write(usage)
    raise SystemExit

def main():
    argc = len(argv)

    cmd = argv[1]
    if cmd == 'generate':
        if argc < 5:
            main_help()
        main_generate(int(argv[2]), argv[3], argv[4])

    elif cmd == 'random_cast':
        if argc < 4:
            main_help()
        nr_threads=int(argv[4]) if argc > 4 else 2
        main_random_cast(argv[2], argv[3], nr_threads=nr_threads)
    elif cmd == 'show':
        if argc < 3:
            main_help()
        main_show(argv[2])
    elif cmd == 'vote':
        if argc < 3:
            main_help()
        if argc == 3:
            main_show(argv[2])
        else:
            main_vote(argv[2], ''.join(argv[3:]))
    else:
        main_help()


if __name__ == '__main__':
    main()
