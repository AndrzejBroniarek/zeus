#!/usr/bin/env python
# -*- coding: utf-8 -*-

from zeus.core import ( c2048, get_random_selection,
                        gamma_encode,
                        encrypt, prove_encryption )

from httplib import HTTPConnection as Conn
from urlparse import urlparse
from urllib import urlencode
from os.path import exists
from sys import argv, stderr
from json import loads, dumps

p, g, q, x, y = c2048()

def generate_voter_file(nr, domain='zeus.minedu.gov.gr'):
    return '\n'.join((u'voter-%d@%s, Ψηφοφόρος %d' % (i, domain, i))
                     for i in xrange(nr))

def generate_vote(p, g, q, y, nr_candidates):
    selection = get_random_selection(nr_candidates, full=0)
    ct = encrypt(gamma_encode(selection, nr_candidates), p, g, q, y)
    alpha, beta, rand = ct
    proof = prove_encryption(p, g, q, alpha, rand)
    commitment, challenge, response = proof
    answer = {}
    answer['encryption_proof'] = (commitment, challenge, response)
    answer['choices'] = [{'alpha': alpha, 'beta': beta}]
    encrypted_vote = {}
    encrypted_vote['answers'] = [answer]
    encrypted_vote['election_uuid'] = ''
    encrypted_vote['election_hash'] = ''
    return encrypted_vote

def get_http_connection(url):
    parsed = urlparse(url)
    default_port = '443' if parsed.scheme == 'https' else '80'
    host, sep, port = parsed.netloc.partition(':')
    if not port:
        port = default_port
    netloc = host + ':' + port
    conn = Conn(netloc)
    conn.path = parsed.path
    return conn

def cast_vote(voter_url):
    conn = get_http_connection(voter_url)
    voter_path = conn.path
    conn.request('GET', voter_path)
    response = conn.getresponse()
    response.read()
    cookie = response.getheader('Set-Cookie').split(';')[0]
    cast_path = '/'.join(voter_path.split('/')[:-3]) + '/cast'
    headers = {'Cookie': cookie}

    election_path = '/'.join(voter_path.split('/')[:-3])
    conn.request('GET', election_path, headers=headers)
    response = conn.getresponse()
    election = loads(response.read())
    pk = election['public_key']
    p = int(pk['p'])
    g = int(pk['g'])
    q = int(pk['q'])
    y = int(pk['y'])
    nr_candidates = len(election['questions'][0]['answers'])

    vote = generate_vote(p, g, q, y, nr_candidates)
    body = urlencode({'encrypted_vote': dumps(vote)})
    conn.request('POST', cast_path, headers=headers, body=body)
    response = conn.getresponse()
    body = response.read()
    if response.status != 200:
        print response.status
    conn.close()

def main_generate(nr, domain, voters_file):
    if exists(voters_file):
        m = "%s: file exists, will not overwrite"
        raise ValueError(m)

    with open(voters_file, "w") as f:
        f.write(generate_voter_file(nr, domain=domain).encode('utf-8'))

def main_cast(voter_url_file):
    voter_urls = open(voter_url_file).read().splitlines()
    total = len(voter_urls)
    for i, voter_url in enumerate(voter_urls):
        print "%d/%d" % (i, total)
        cast_vote(voter_url)

def main_help():
    usage = ("Usage: ./zeus-voter generate <nr_voters> <domain> <voters.csv>\n"
             "       ./zeus-voter cast <voter_url_file>\n")

    stderr.write(usage)
    raise SystemExit

def main():
    argc = len(argv)

    usage = ("Usage: ./zeus-voter generate <nr> <domain> <voters.csv>\n"
             "       ./zeus-voter cast <voter_url_file>\n")

    if argc < 3:
        main_help()

    if argv[1] == 'generate':
        if argc < 5:
            main_help()

        main_generate(int(argv[2]), argv[3], argv[4])

    elif argv[1] == 'cast':
        main_cast(argv[2])

    else:
        main_help()


if __name__ == '__main__':
    main()
