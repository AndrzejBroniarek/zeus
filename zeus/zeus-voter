#!/usr/bin/env python
# -*- coding: utf-8 -*-

from zeus.core import ( c2048, get_random_selection,
                        gamma_encode,
                        encrypt, prove_encryption )

from httplib import HTTPConnection, HTTPSConnection
from urlparse import urlparse
from urllib import urlencode
from os.path import exists
from sys import argv, stderr
from json import loads, dumps
from Queue import Queue, Empty
from threading import Thread

p, g, q, x, y = c2048()

def generate_voter_file(nr, domain='zeus.minedu.gov.gr'):
    return '\n'.join((u'voter-%d@%s, Ψηφοφόρος, %d' % (i, domain, i))
                     for i in xrange(nr))

def generate_vote(p, g, q, y, nr_candidates):
    selection = get_random_selection(nr_candidates, full=0)
    encoded = gamma_encode(selection, nr_candidates)
    ct = encrypt(encoded, p, g, q, y)
    alpha, beta, rand = ct
    proof = prove_encryption(p, g, q, alpha, rand)
    commitment, challenge, response = proof
    answer = {}
    answer['encryption_proof'] = (commitment, challenge, response)
    answer['choices'] = [{'alpha': alpha, 'beta': beta}]
    encrypted_vote = {}
    encrypted_vote['answers'] = [answer]
    encrypted_vote['election_uuid'] = ''
    encrypted_vote['election_hash'] = ''
    return encrypted_vote, encoded

def get_http_connection(url):
    parsed = urlparse(url)
    if parsed.scheme == 'https':
            default_port = '443'
            Conn = HTTPSConnection
    else:
            default_port = '80'
            Conn = HTTPConnection
    host, sep, port = parsed.netloc.partition(':')
    if not port:
        port = default_port
    netloc = host + ':' + port
    conn = Conn(netloc)
    conn.path = parsed.path
    return conn

def cast_vote(voter_url):
    conn = get_http_connection(voter_url)
    voter_path = conn.path
    conn.request('GET', voter_path)
    response = conn.getresponse()
    response.read()
    cookie = response.getheader('Set-Cookie')
    if not cookie:
        raise RuntimeError("Cannot get cookie")
    cookie = cookie.split(';')[0]
    cast_path = '/'.join(voter_path.split('/')[:-3]) + '/cast'
    headers = {'Cookie': cookie}

    election_path = '/'.join(voter_path.split('/')[:-3])
    conn.request('GET', election_path, headers=headers)
    response = conn.getresponse()
    election = loads(response.read())
    pk = election['public_key']
    p = int(pk['p'])
    g = int(pk['g'])
    q = int(pk['q'])
    y = int(pk['y'])
    nr_candidates = len(election['questions'][0]['answers'])

    vote, encoded = generate_vote(p, g, q, y, nr_candidates)
    body = urlencode({'encrypted_vote': dumps(vote)})
    conn.request('POST', cast_path, headers=headers, body=body)
    response = conn.getresponse()
    body = response.read()
    if response.status != 200:
        print response.status
    conn.close()
    return encoded

def main_generate(nr, domain, voters_file):
    if exists(voters_file):
        m = "%s: file exists, will not overwrite" % (voters_file,)
        raise ValueError(m)

    with open(voters_file, "w") as f:
        f.write(generate_voter_file(nr, domain=domain).encode('utf-8'))

def main_cast_thread(inqueue, outqueue):
    while 1:
        try:
            o = inqueue.get_nowait()
            if not o:
                break
        except Empty, e:
            break
        i, total, voter_url = o
        print "%d/%d" % (i, total)
        encoded = cast_vote(voter_url)
        outqueue.put(encoded)

def main_cast(voter_url_file, plaintexts_file, nr_threads=2):
    if exists(plaintexts_file):
	m = "%s: file exists, will not overwrite" % (plaintexts_file,)
	raise ValueError(m)
    f = open(plaintexts_file, "w")

    voter_urls = open(voter_url_file).read().splitlines()
    total = len(voter_urls)
    inqueue = Queue(maxsize=total)
    outqueue = Queue(maxsize=total)
    for i, voter_url in enumerate(voter_urls):
        inqueue.put((i, total, voter_url))

    #main_cast_thread(queue)
    threads = [Thread(target=main_cast_thread, args=(inqueue, outqueue))
               for _ in xrange(nr_threads)]

    for t in threads:
        t.start()

    plaintexts = [outqueue.get() for _ in xrange(total)]
    f.write(repr(plaintexts))
    f.close()

    for t in threads:
        t.join()

def main_help():
    usage = ("Usage: ./zeus-voter generate <nr> <domain> <voters.csv>\n"
             "       ./zeus-voter cast <voter_url_file> <plaintexts_file> [nr_threads]\n")
    stderr.write(usage)
    raise SystemExit

def main():
    argc = len(argv)

    if argc < 4:
        main_help()

    if argv[1] == 'generate':
        if argc < 5:
            main_help()

        main_generate(int(argv[2]), argv[3], argv[4])

    elif argv[1] == 'cast':
        nr_threads=int(argv[4]) if argc > 4 else 2
        main_cast(argv[2], argv[3], nr_threads=nr_threads)
    else:
        main_help()


if __name__ == '__main__':
    main()
