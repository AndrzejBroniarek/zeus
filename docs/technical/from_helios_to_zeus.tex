\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{amsmath}

\usepackage{url}
\urldef{\mails}\path|{gtsouk, kpap, louridas, tsanakas}@grnet.gr|

\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{From Helios to Zeus}

\titlerunning{From Helios to Zeus}

\author{Georgios Tsoukalas%
\and Kostas Papadimitriou%
\and Panos Louridas%
\and Panayiotis Tsanakas}

\authorrunning{Tsoukalas, Papadimitriou, Louridas and Tsanakas}

\institute{Greek Reseach and Education Network,\\
56 Mesogeion Avenue, Athens, Greece\\
\mails\\
\url{http://www.grnet.gr}}

\maketitle

\begin{abstract}
  We present Zeus, an Internet ballot casting and counting system
  based on Helios that allows elections in which ballots cannot be
  tallied homomorphically. Zeus separates the production of election
  results from voting and counting, thus allowing any type of
  elections to be carried out, while maintaining the main features of
  the original Helios system in terms of anonymity and verifiability.
  \keywords{Internet voting, voting systems, electronic ballots}
\end{abstract}


\section{Introduction}

Helios is a well known system for Internet voting, in which the whole
process is carried out through digital means---there is no paper
trace, nor ballots in physical forms. It has been used in several real
world elections and its basic architectural design has proven robust.

In this paper we present Zeus, a system based on Helios, which extends
Helios's range of applications while reducing the actual work
performed by Helios and its role in the election process. Helios is a
system that performs \emph{ballot casting}, \emph{ballot counting},
and \emph{production of election results}. Zeus performs only the
first two, leaving the production of election results to other
systems. In this way, it can accommodate more voting systems than
Helios, which currently supports only approval-like voting.

\section{Roots and Rationale}

Zeus was initiated after the use of electronic vote was permitted by
decree for the election of the Governing Councils of Higher Education
Institutions in Greece. In each institution the Governing Council is
directly elected by its faculty and is its main governing body. The
election uses the Single Transferable Vote (STV) system, in which
voters do not simply indicate the candidates of their preference, but
also rank them in order of preference. 

When we were charged with providing an implementation of a system
implementing electronic voting we decided to investigate Helios's
suitability, as we needed a mature system with a proven record in real
world elections and published open source code. The current version of
Helios (version 3) allows internet election from end-to-end: from the
moment the voter casts a ballot through a web browser to the
publication of election results. It does that by never actually
decrypting the ballots but performing a series of homomorphic
calculations on them. In the end, the results of the calculations are
decrypted and published. 

Although using a single system for the whole process is appealing, the
use of homomorphic counting in Helios cannot accommodate voting
systems in which not just the individual choices on the ballot matter,
but the whole ballot itself. In STV, homorphical tallying could pass
to the STV algorithm the information that a certain candidate has been
selected in rank $r$ by $n$ voters, but this is not enough, as the whole
ballot and not just each rank separately is passed around during STV's
counting rounds.

We realised, however, that it is not necessary to use Helios's
homomorphic counting capabilities. We decided to use Helios for
\emph{counting the ballots}, not for producing the election results.
Once we do have a veriable ballots count, this can be fed to an STV
calculator, or indeed to a calculator of any voting system. Since the
ballots are published, and the algorithm is also published, a third
party can always verify that the results are correct.

Interestingly, the original publication of Helios~\cite{adida:2008}
did not use homomorphic tallying, but relied on mixnets for
guaranteeing voter anonymity. 

\section{Ballot Casting and Encoding}

In Helios, ballots consist of answers to binary ``yes'' or ``no''
questions, framed in the appropriate way. For instance, a voter
indicates $k$ out of $n$ candidates on a ballot by selecting them, in
which case the answer ``Would you like X as a Y?'' gets a yes (1),
otherwise a no (0). In STV, as in any system in which we would need
the whole ballot to be decrypted in the end, the ballot must be
encoded in some way. We encode each ballot as a integer by assigning a
unique number to each possible candidate selection and ranking. The
total number of possible ballots is $p _{n1} + p_{n2} + \cdots + p
_{nk}$, where $p_{nk}$ is the number of sequences of $k$ objects out
of $n$, that is $p_{nk} = n(n - 1)\cdots(n - k + 1)$\footnote{The
  number $p_{nk}$ is also written $n^{\underline{k}}$, or $(n)_k$,
  called ``Pochhammer's symbol''~\cite[p.\ 48]{graham:1994}. In closed
  form it is $p_{nk} = \sum_{k=0}^{n} (-1)^{n-k}\left\{n \atop
    k\right\}x^k$, where $\left\{n \atop k\right\}$ is the Stirling
  number of the first kind~\cite{weisstein:pochhammer}.}. As each
ballot is sent in encrypted form to the Zeus server, for its encoding
number $b$ we must have $b \in [0, 10^p]$, where $p$ is the order of
the group used in the ElGamal encryption scheme, so the encoding does
not present a practical limit in real elections (if it did, we could
always break the number in parts and send them separately).

We encode each ballot as an integer by enumerating the set
$\mathcal{E}$ of all possible ballots.
Our method is, take $s$ candidates out of $N$,
for $0\leq s \leq C$, where $C$ is the maximum choices allowed
in the ballots \footnote{$N=C$ for the elections we hosted},
and then take their $s!$ permutations.
Summing it up, all the possible ballots are
\begin{equation}
\label{eq:max_encoded}
|\mathcal{E}| = \sum^{s}_{k=0}\binom{N}{k}k! \quad
\hbox{\small where} \quad 0\leq s \leq C
\end{equation}
In the enumeration, we first count the smaller selections
(i.e. take \textit{zero} candidates,
      then \textit{one}, then \textit{two}, \ldots)
so that for small candidate selection sets the encoded
ballot will have a small value, thus saving valuable bit-space.
\footnote{
For example, selecting up to all of 300 candidates needs 2048 bits,
while selecting 10 out of 1000 candidates needs only 100 bits.}

% gtsouk: describe the exact encoding / decoding algorithm for the
% ballots. 

\section{the Cryptographic Model}

We have collected all cryptographic aspects of Zeus elections
and implemented them into a generic, standalone, and extensible software module.
\footnote{\texttt{zeus.core}}
This module implements an abstract version of the election workflow,
all the required cryptographic functions, and all validations of data
and the workflow itself.
This module is fitted into the production environment by software extensions
(i.e. subclassing) where the web application uses it as needed.

\subsection{Software Dependencies}
Random number generation \emph{(Fortuna)},
primality testing \emph{(Miller-Rabin)} and modulo inversion from
\texttt{PyCrypto}. Exponentiation from \texttt{libgmp} via \texttt{gmpy}
(really faster than Python's builtin \texttt{pow}).
We implement all other operations in native Python and
the Python standard library, including hashing.
We have studied \texttt{Helios}, \texttt{PloneVoteCryptoLib},
\texttt{PyCrypto} for our implementation.

\subsection{Cryptosystem}
Zeus uses the ElGamal cryptosystem on the prime-order-$q$ subgroup
$\mathcal{G}$ of the quadratic residues of a safe prime $p = 2q + 1$,
such that
$$m \in \mathcal{G} \longleftrightarrow \mathcal{L}(m) = m^q = 1 \mod p$$
$\mathcal{L}$ being the \emph{Legendre} symbol.
For reference, we reproduce all the primitives we use in a table.
All base numbers are in $\mathcal{G}$, all exponents in $\mathbb{Z}^{*}_q$,
and all operations are $\mod p$, unless explicitly noted.
We group $x=a, y=b, \ldots$ as $(x,y,\ldots)\equiv(a,b,\ldots)$.

\begin{tabular}{rl}
\textbf{modulus}       \, & $p \equiv 3(\mod 4)$ \hfill\textit{\small(safe prime)}\\
\textbf{generator}     \, & $g: g^q = 1$      \\
\textbf{order}         \, & $q = (q-1)/2$\hfill\textit{\small(ElGamal group prime order)}\\
\textbf{secret}        \, & $x$               \\
\textbf{public}        \, & $y = g^x$         \\
\textbf{committment}   \, & $t$               \\
\textbf{challenge}     \, & $c$               \\
\textbf{response}      \, & $f$     \hfill\textit{\small(from proof)} \\
\textbf{\parbox{7em}
    {\setlength{\baselineskip}{.85\baselineskip}
     \raggedleft
     group \\
     encoding}}        \, & $T: x \mapsto \left\{
                            \begin{matrix}  x &,&\quad x^q=1 \\
                                           -x &,&\quad x^q\neq 1
                            \end{matrix}\right.\quad
                            T^{-1}: e \mapsto \left\{
                            \begin{matrix}  e &,&\quad e \leq q \\
                                           -e &,&\quad e > q \\
                            \end{matrix}\right.
                            $ \\
\textbf{secret nonce}  \, & $r, w$  \hfill\textit{\small(in encryptions and proofs)} \\
\textbf{ciphertext}    \, & $(a, b)\equiv(g^r, y^r m$)
                                    \hfill\textit{\small(encryption)} \\
\textbf{plaintext}     \, & $m = a^{-x}b$
                                    \hfill\textit{\small(decryption)} \\
\textbf{reencryption}  \, & $(a',b')\equiv(g^{r'}a, y^{r'}b)$ \\
\textbf{hashing}       \, & $\mathcal{H}(n_0n_1n_2\ldots)$
                            \hfill\textit{\small(hash textual representation of numbers)} \\
\textbf{discrete log}  \, & $y = g^x \Rightarrow \log_gy=x \;\leadsto\;$
                                    \textbf{\small prove you know} $x$ \\
                       \, & $(t, c, f) \equiv (g^w, \mathcal{H}(t), w+xc)$
                                    \hfill\textit{\small(prove knowledge)} \\
                       \, & $g^f \overset{?}{=} ty^c$
                                    \hfill\textit{\small(verify knowledge)} \\
                       \, & $g, y, u, v \;\leadsto\;$
                                    \textbf{\small prove} $\:log_gu = log_yv = w$
                                    i.e. $(g, y, g^w, y^w)$ \\
                       \, & $(t_g,t_y,c,f) \equiv (g^w, y^w, \mathcal{H}(t_gt_y), w+xc)$
                                    \hfill\textit{\small(prove equality)} \\
                       \, & $g^f \overset{?}{=} t_gu^c \wedge
                             y^f \overset{?}{=} t_yv^c$
                                    \hfill\textit{\small(verify equality)} \\
\textbf{signature}     \, & $(z, s)\equiv\big(g^{w}, w^{-1}(m-zx)\mod (p-1)\big)
                                    \quad w = 2w'-1,\: 3\leq w'\leq q$ \\
                       \, & $m^s \overset{?}{=} y^zz^s$
                                    \hfill\textit{\small(verify signature)} \\
% TODO: cite Fiat-Shamir, Schnorr, Chaum-Pedersen, HAC in this table
\end{tabular}

\subsection{Creating}
\subsection{Voting}
\subsection{Mixing}
\subsection{Decrypting}
\subsection{Validation}

\section{Election User Interface}
A significant design goal was \emph{interface},
and \emph{workflow} simplicity,
since voters are not required to understand cryptography
or information flow on computer systems.
At the same time,
the informed voter needed access to all information and functions needed
to both understand and verify the process.

\subsection{Administrator View}
\subsection{Voting Booth}
\subsection{Auditing}


\section{Ballot Submission}

The submitted ballot contains
%gtsouk: describe the conntents of the submitted ballot
A submitted ballot is a JSON object of the form:
\begin{verbatim}
{
  answers : [];
  election_hash : ;
  election_uuid : ;
}
\end{verbatim}

\section{Election Verification}

%gtsouk: describe the election verification algorithm

\section{The Election Workflow in Zeus}

The election workflow in Zeus comprises the steps:

\begin{enumerate}

\item The election authority compiles the list of candidates and the
  voters' registry, and appoints the election committee, the poll
  opening date and time and its closing date and time.

\item The voters receive at their mailboxes a message inviting them to
  cast their vote. The message contains a link that leads them to the
  ``voting booth'', where they can compile their ballot. The voting
  booth opens at the date and time appointed by the election
  authority; if the voters visit the link before, they are informed
  accordingly. After casting their vote, voters receive via e-mail a
  proof of their ballot cast.

\item When the poll closes, the election committee starts the ballot
  tallying process.

\end{enumerate}

The whole process is explained in more detail below.

\subsection{Preparing the Election}

\subsubsection{Notifications to the Election Committee}

\subsubsection{Generation of Election Keys}

\subsubsection{Candidates Addition}

\subsubsection{Voters Addition}

\subsubsection{Election Freeze}

\subsection{Voting}

\subsection{Tallying}

\section{Implementation Considerations}

% gtsouk: Including timing measurements, especially wrt differen versions of
% Python, GMP, etc.

% gtsouk: also instances where existing implementations were not up to
% par from a cryptographic point of view

\bibliographystyle{splncs}
\bibliography{zeus}

\end{document}


